<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  
  <title> Datalog | CS294-260 </title>
  
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta property="og:title" content="Datalog" />
  <style>
    body {
      margin: 0 auto;
      max-width: 1200px;
      padding: 0 1em;
      background-color: #FED;
      color: #111;
      font-size: 120%;
      line-height: 1.2;
    }

    .center {
      text-align: center;
    }

    nav a {
      padding: 0.5ex;
    }

    footer {
      text-align: center;
      padding-top: 3em;
      color: #666;
      font-size: 70%;
    }
  </style>
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$']],
        processEscapes: true,
        tags: 'ams',
      },
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>
  <main>
    <h1 class="center"> Declarative Program Analysis and Optimization </h1>
    <h3 class="center"> CS294-260, Spring 2024 </h3>

    <nav class="center">
      <div id="links">
        <a href="/~cs294-260/sp24/">Home</a>
        
        <a href="/~cs294-260/sp24/2024-01-17-welcome">Policies</a>
        <a href="https://bcourses.berkeley.edu/courses/1532818">bCourses</a>
        
      </div>
    </nav>

    <style>
    #post {
        max-width: 800px;
        margin: 0 auto;
    }
</style>

<div id="post" class="content">

    <h2>Datalog</h2>

    <ul>
        <li><time>Monday, February 5, 2024</time></li>
        
        
    </ul>

    <style>
    code { 
      font-size: 120%; 
      white-space: pre;
    }
    tr { vertical-align: middle; }
    table {
        border-spacing: 0;
        margin: auto;
    }
    td { padding: 0.1em 0.5em; }
    tbody tr:nth-child(odd) {background-color: #00000011;}
</style>

<p><a href="https://en.wikipedia.org/wiki/Datalog">Datalog</a>
 is a declarative logic programming language
 that comes from the database theory and logic programming 
 communities.
While there are many perspectives on Datalog,
 we are going to focus on it from an operational perspective,
 and draw some comparisons to term rewriting systems.</p>

<ul id="markdown-toc">
  <li><a href="#resources" id="markdown-toc-resources">Resources</a></li>
  <li><a href="#simple-example" id="markdown-toc-simple-example">Simple Example</a></li>
  <li><a href="#optimization" id="markdown-toc-optimization">Optimization</a>    <ul>
      <li><a href="#semi-naive-evaluation" id="markdown-toc-semi-naive-evaluation">Semi-naive Evaluation</a></li>
      <li><a href="#magic-sets" id="markdown-toc-magic-sets">Magic Sets</a></li>
    </ul>
  </li>
  <li><a href="#extensions" id="markdown-toc-extensions">Extensions</a>    <ul>
      <li><a href="#negation" id="markdown-toc-negation">Negation</a></li>
      <li><a href="#from-booleans-to-integers-lattices-and-semi-rings" id="markdown-toc-from-booleans-to-integers-lattices-and-semi-rings">From Booleans to Integers, Lattices, and Semi-rings</a></li>
      <li><a href="#existentials-adts-egds-and-tgds" id="markdown-toc-existentials-adts-egds-and-tgds">Existentials, ADTs, EGDs, and TGDs</a></li>
    </ul>
  </li>
</ul>

<h2 id="resources">Resources</h2>

<p>There are a lot of great resources out there on Datalog.
Here are just a few:</p>
<ul>
  <li><a href="https://en.wikipedia.org/wiki/Datalog">Wikipedia</a> has a nice overview.</li>
  <li><a href="https://souffle-lang.github.io/">Souffle</a> is a modern Datalog implementation
that provides a nice <a href="https://souffle-lang.github.io/tutorial">tutorial</a> and
other documentation.</li>
  <li><a href="http://webdam.inria.fr/Alice/">Foundations of Databases</a> (the “Alice book”) 
is a classic textbook on databases that covers Datalog. 
It’s available online at that link.</li>
  <li>Philip Zucker has a 
<a href="https://www.philipzucker.com/notes/Languages/datalog/">notes pages</a>,
many blog posts,
and an <a href="https://www.philipzucker.com/datalog-book">online book</a> (in progress)
on Datalog
(and other topics relevant to this course!).</li>
  <li>The following survey papers:
    <ul>
      <li><a href="http://blogs.evergreen.edu/sosw/files/2014/04/Green-Vol5-DBS-017.pdf">Datalog and Recursive Query Processing</a></li>
      <li><a href="https://soft.vub.ac.be/Publications/2022/vub-tr-soft-22-21.pdf">Modern Datalog Engines</a></li>
    </ul>
  </li>
</ul>

<h2 id="simple-example">Simple Example</h2>

<p>Let’s start by looking at a classic Datalog program
 to compute paths in a graph,
 and we’ll describe it in the typical, operational way:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>edge(1, 2).
edge(2, 3).
edge(3, 4).

path(X, Y) :- edge(X, Y).
path(X, Z) :- edge(X, Y), path(Y, Z).
</code></pre></div></div>

<p>This program defines a <em>database</em> of facts 
 and a set of <em>rules</em> that can be used to derive new facts.
Each line of the form <code class="highlighter-rouge">edge(1, 2).</code> is a fact,
 stating that the binary relation <code class="highlighter-rouge">edge</code> contains the tuple <code class="highlighter-rouge">(1, 2)</code>.
The program begins evaluation with the following state:</p>

<table>
  <thead>
    <tr>
      <th>time</th>
      <th><code class="highlighter-rouge">edge</code></th>
      <th><code class="highlighter-rouge">path</code></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>(1, 2)</td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>(2, 3)</td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>(3, 4)</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>So at timestep 0, the database only contains
 those tuples given by facts from the program.
Then the program will apply rules to derive new facts.
Let’s begin with the first rule, <code class="highlighter-rouge">path(X, Y) :- edge(X, Y).</code>
Datalog rules can be read as a backward implication:
 “if the right-hand side is true, then the left-hand side is true”.
So to apply one step of this rule, 
 we look for tuples in the <code class="highlighter-rouge">edge</code> relation
 and add them to the <code class="highlighter-rouge">path</code> relation.</p>

<table>
  <thead>
    <tr>
      <th>time</th>
      <th><code class="highlighter-rouge">edge</code></th>
      <th><code class="highlighter-rouge">path</code></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>(1, 2)</td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>(2, 3)</td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>(3, 4)</td>
      <td> </td>
    </tr>
    <tr>
      <td>1</td>
      <td> </td>
      <td>(1, 2)</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>(2, 3)</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>(3, 4)</td>
    </tr>
  </tbody>
</table>

<p>At this point, it’s worth noting that 
 the “base case” rule will not add anything else to the database.
Relations are sets in Datalog,
 so adding the same tuple twice has no effect.
So given that we never add anything else to the <code class="highlighter-rouge">edge</code> relation,
 the rule <code class="highlighter-rouge">path(X, Y) :- edge(X, Y)</code> is done at this point.</p>

<p>Now we move on to the “inductive” rule: <code class="highlighter-rouge">path(X, Z) :- edge(X, Y), path(Y, Z).</code>
This rule epitomizes the recursive nature of Datalog rules.
In plain English, it says 
 “if there is an edge from <code class="highlighter-rouge">X</code> to <code class="highlighter-rouge">Y</code> and a path from <code class="highlighter-rouge">Y</code> to <code class="highlighter-rouge">Z</code>,
  then there is a path from <code class="highlighter-rouge">X</code> to <code class="highlighter-rouge">Z</code>”.</p>

<p>Let’s inspect the right-hand side of the rule 
 (also called the <em>body</em> or the <em>query</em>)
 a little more.
The body of a Datalog rule is a conjunction of <em>atoms</em>,
 so the comma is read as “and”.
The capital letters (using the convention from Prolog) are variables,
 bound by the body and used in the head (the left hand side).
The first step of applying this rule is to
 search for substitutions
 that make the body true, i.e., 
 mappings from variables to values such that 
 both <code class="highlighter-rouge">edge(X, Y)</code> and <code class="highlighter-rouge">path(Y, Z)</code> are in the database.
A reader familiar with databases might recognize this as a 
 <a href="https://en.wikipedia.org/wiki/Conjunctive_query"><em>conjunctive query</em></a>,
 which is typically answered by 
 a join operation in a relational database.</p>

<p>Now let’s apply the inductive rule. 
 Looking at timestep 1, we find the following 
 substitutions for <code class="highlighter-rouge">X, Y, Z</code> that make the body true: 
 <code class="highlighter-rouge">(1, 2, 3)</code> and <code class="highlighter-rouge">(2, 3, 4)</code>.
The result is adding <code class="highlighter-rouge">path</code>s <code class="highlighter-rouge">(1, 3)</code> and <code class="highlighter-rouge">(2, 4)</code> to the database
 in the next timestep:</p>

<table>
  <thead>
    <tr>
      <th>time</th>
      <th><code class="highlighter-rouge">edge</code></th>
      <th><code class="highlighter-rouge">path</code></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>(1, 2)</td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>(2, 3)</td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>(3, 4)</td>
      <td> </td>
    </tr>
    <tr>
      <td>1</td>
      <td> </td>
      <td>(1, 2)</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>(2, 3)</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>(3, 4)</td>
    </tr>
    <tr>
      <td>2</td>
      <td> </td>
      <td>(1, 3)</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>(2, 4)</td>
    </tr>
  </tbody>
</table>

<p>And finally,
 the next time step finds a path from 1 to 4:</p>

<table>
  <thead>
    <tr>
      <th>time</th>
      <th><code class="highlighter-rouge">edge</code></th>
      <th><code class="highlighter-rouge">path</code></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>(1, 2)</td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>(2, 3)</td>
      <td> </td>
    </tr>
    <tr>
      <td> </td>
      <td>(3, 4)</td>
      <td> </td>
    </tr>
    <tr>
      <td>1</td>
      <td> </td>
      <td>(1, 2)</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>(2, 3)</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>(3, 4)</td>
    </tr>
    <tr>
      <td>2</td>
      <td> </td>
      <td>(1, 3)</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td>(2, 4)</td>
    </tr>
    <tr>
      <td>3</td>
      <td> </td>
      <td>(1, 4)</td>
    </tr>
  </tbody>
</table>

<p>At this point, 
 the program has reached a <em>fixed point</em>,
 applying the rules no longer 
 adds any new facts to the database.</p>

<h2 id="optimization">Optimization</h2>

<p>Datalog is a very declarative language,
 and as such it’s amenable to many kinds of optimization.</p>

<p>One big one that we <em>won’t</em> talk about too much is
 <em>query optimization</em>.
A big part of running Datalog is evaluating the queries
 that form the bodies of the rules.
These are “just” conjunctive queries (like SQL joins),
 and so there are decades of research on optimizing them
 and executing them efficiently.
One of the big pros of Datalog
 is that it gets to borrow all of that work;
 in fact some Datalog engines are built
 on top of standard SQL engines.</p>

<p>Other optimizations can be framed in terms of
 syntactic transformations of the program;
 something that probably feels more at home
 to programming languages folks.
We’ll talk about two of the most common:
  <em>semi-naive evaluation</em> which incrementalizes Datalog, 
  and <em>magic sets</em> which blurs the boundary between top-down and bottom-up evaluation.</p>

<h3 id="semi-naive-evaluation">Semi-naive Evaluation</h3>

<p>Let’s return to our path-finding example.
After time step 1, 
 it’s obvious that the rule <code class="highlighter-rouge">path(X, Y) :- edge(X, Y)</code> 
 will no longer add anything to the database.
Why is that?
Since the <code class="highlighter-rouge">edge</code> relation doesn’t change,
 the rule will never find any new tuples to add to the <code class="highlighter-rouge">path</code> relation.</p>

<p>The other rule is a bit more complicated,
 but will make the general case clear.
The rule <code class="highlighter-rouge">path(X, Z) :- edge(X, Y), path(Y, Z)</code>
 involves a join between the <code class="highlighter-rouge">edge</code> and <code class="highlighter-rouge">path</code> relations.
Let’s consider where “new” <code class="highlighter-rouge">path</code> tuples might come from.
Well, the <code class="highlighter-rouge">edge</code> relation is fixed,
 so the only way to get new <code class="highlighter-rouge">path</code> tuples
 is if the <code class="highlighter-rouge">path</code> relation changes.
In general, a join can only produce new tuples
 if one of the relations changes.
Let’s make this more precise:
 for two relations $R$ and $S$,
 we’ll write $RS$ for their join.
Let $\Delta R$ be the new tuples to be added to $R$,
 so that $R + \Delta R$ will the be “next” iteration of $R$.
Then some algebraic manipulation shows that:</p>

<div class="kdmath">$$
\begin{align*}
RS + \Delta(RS) &= (R + \Delta R)(S + \Delta S) \\
RS + \Delta(RS) &= RS + R\Delta S + S\Delta R + \Delta R \Delta S \\
     \Delta(RS) &= \hspace{2.64em} R\Delta S + S\Delta R + \Delta R \Delta S \\
\end{align*}
$$</div>

<p>The key step here is the recognition that 
 we only actually need to compute $\Delta(RS)$,
 since we already have $RS$ from the previous iteration.
This saves us from having to join (old) $R$ with (old) $S$,
 since we’ve already done that work.
This is the essence of <em>semi-naive evaluation</em>:
 to compute the new tuples of a join,
 you need to join new-with-new, new-with-old, old-with-new,
 <strong>but not</strong> old-with-old.</p>

<p>Most datalog implementations feature semi-naive evaluation.
It can be implemented almost entirely as a syntactic transformation,
 rewriting a join over many relations into
 a union of many joins over new/old parts.
To support this,
 most Datalog engines will explicitly maintain the “new” and “old” 
 parts of each relation.</p>

<h3 id="magic-sets">Magic Sets</h3>

<p>Datalog is typically evaluated <em>bottom-up</em>,
 which means facts are computed in order of the size of their derivation tree.
This allows for efficient execution in many contexts, but it can be wasteful.
Consider our path-finding example again.
Running the program computes all paths in the graph.
In fact,
 the Datalog program to compute path reachability in a graph
 is very similar to the <a href="https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm">Floyd-Warshall algorithm</a> for all-pairs shortest paths.</p>

<p>But what if we only want to ask about a specific path between,
 say, vertices 42 and 56?
It would be wasteful to compute all paths in the graph
 if we only want to know about some of them?
We could manually write such a Datalog program:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>path_from_42(42, X) :- edge(42, X)
path_from_42(X, Z) :- path_from_42(X, Y), edge(Y, Z)
</code></pre></div></div>

<p>The <code class="highlighter-rouge">path_from_42</code> relation will contain precisely 
 those edges that are on a path from 42 to some other vertex.</p>

<p>The magic set transformation is a way to automatically
 generate such a program from the more 
 general one that we wrote earlier.
If given a <em>goal</em> query to compute, say <code class="highlighter-rouge">path(42, X)</code>,
 the magic set transformation 
 transform the original program into a new one
 that only computes the facts necessary to answer the goal query.
This goal-directedness means that magic set gives Datalog a top-down flavor,
 but it doesn’t actually change the (bottom up) evaluation strategy.</p>

<p>The details of how it works are beyond the scope of this lecture,
 but we’ll see a “souped-up” version of magic set in the 
 paper on <a href="./2024-02-21-datalog-fp">Functional Programming in Datalog</a>.</p>

<h2 id="extensions">Extensions</h2>

<p>Datalog is a simple language,
 which makes it amendable to many extensions.
There are many, many extensions to Datalog;
 we’ll only mention a few that are relatively standard in the literature
 and that are relevant to the themes of this course.</p>

<h3 id="negation">Negation</h3>

<p>Negation in the head of a rule is
 tricky (but well studied in the literature),
 so we’ll focus on negation in the body of a rule.
Consider the following extension to our path-finding example:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>disconnected(X, Y) :- not path(X, Y).
</code></pre></div></div>

<p>This rule computes the disconnected pairs of vertices in the graph.
Intuitively,
 this rule makes sense,
 and the intuitive method of computing it essentially how it’s done in practice:
 first compute <code class="highlighter-rouge">path</code>, then compute <code class="highlighter-rouge">disconnected</code> from <code class="highlighter-rouge">path</code>.
The general version of this is called <em>stratified negation</em>.<sup id="fnref:negation"><a href="#fn:negation" class="footnote">1</a></sup>
This approach splits the program into <em>strata</em>
 such that:</p>
<ul>
  <li>All rules that share a head relation are in the same stratum.
    <ul>
      <li>We say that the stratum containing rules with <code class="highlighter-rouge">R</code> in the head <em>defines</em> <code class="highlighter-rouge">R</code>.</li>
    </ul>
  </li>
  <li>A rule <code class="highlighter-rouge">... :- S(..), ...</code> must be in same or a higher stratum than the one that defines <code class="highlighter-rouge">S</code>.</li>
  <li>A rule <code class="highlighter-rouge">... :- not S(..), ...</code> must be <em>a strictly</em> higher stratum than the one that defines <code class="highlighter-rouge">S</code>.</li>
</ul>

<p>Stratification basically splits a Datalog program into a sequence of programs
 that can be evaluated in order,
 so no special implementation is needed to support this flavor of negation.
However, some Datalog programs cannot be stratified.
Consider trying to compute nodes in a graph
 that are only reachable via an <em>odd number</em> of steps
 from a given source (42):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>odd(X) :- edge(42, X).
odd(Y) :- not odd(X), edge(X, Y).
</code></pre></div></div>

<p>This program cannot be stratified,
 so we cannot use stratified negation to compute it.
There are other models of negations in Datalog,<sup id="fnref:negation:1"><a href="#fn:negation" class="footnote">1</a></sup>
 but they are less frequently used than the relatively simple stratified negation.</p>

<h3 id="from-booleans-to-integers-lattices-and-semi-rings">From Booleans to Integers, Lattices, and Semi-rings</h3>

<p>We typically think of the output (and state) of a Datalog
 program as a bunch of <em>relations</em>,
 where each relation is a set of tuples.
But we can also think of the output as a bunch of <em>functions</em>,
 where each function maps the input tuple to a value.
If we have our functions output booleans,
 then we can reconstruct the behavior of Datalog with relations:</p>

<div class="kdmath">$$
f_R(x, y, z) =
  \begin{cases}
   \textsf{true}  &\text{ when } (x, y, z) \in R \\
   \textsf{false} &\text{ otherwise}
  \end{cases}
$$</div>

<p>What about other output types for those functions?
This is an exciting area of research in Datalog,
 figuring out what kinds of values we can output
 from those functions and still preserve the nice properties of Datalog.
Recall the semi-naive evaluation section, where
 we used some of the algebraic properties of sets rearrange
 those formula and derive a more efficient algorithm.
The algebraic properties of the values you are working with in Datalog
 determine what kinds of optimizations you can do.</p>

<p>Typically literature on this topic will refer to two kinds of
 operations on the output of these functions:</p>
<ul>
  <li><strong>joint use</strong>, written as $\times$,
occurs when we jointly use multiple values.
For example, 
in the boolean case of <code class="highlighter-rouge">path(x, z) :- edge(x, y), path(y, z).</code>,
the comma denotes joint use and is interpreted as “and”.</li>
  <li><strong>alternative use</strong>, written as $+$,
occurs when we derive a value multiple times. 
This occurs when a tuple is derived multiple times.
For example,
 there maybe a multiple different paths from node 12 to 63,
 so what happens to the value of <code class="highlighter-rouge">path(12, 63)</code> when it is derived multiple times?
In the boolean case, 
 $+$ is interpreted as “or”, 
 so basically nothing happens;
 if we’ve derived it once, there’s nothing else to add.</li>
</ul>

<p>The literature on this topic mostly centers around dealing with
 <em>lattices</em> and (more generally) <em>semi-rings</em>.
We will see more about this in our discussion of the
 <a href="./2024-02-12-flix">Flix</a> Datalog system.</p>

<p>A great example is working in “min-plus” semi-ring,
 where we use:<sup id="fnref:minplus"><a href="#fn:minplus" class="footnote">2</a></sup></p>
<ul>
  <li>$\min$ as our alternative use (instead of boolean and)</li>
  <li>$+$ as our joint use (instead of boolean or)</li>
</ul>

<p>Just by changing our semi-ring from boolean to min-plus,
 our path reachability program becomes shortest path!
This is easy to see if you write it all out.
So this Datalog program:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>path(x, z) :- edge(x, z).
path(x, z) :- edge(x, y), path(y, z).
</code></pre></div></div>

<p>in the boolean semi-ring corresponds to the following formula:</p>

<div class="kdmath">$$
\textsf{path}(x, z) = 
  \textsf{edge}(x, z) \vee
\exists y.
\left(
  \textsf{edge}(x, y) \wedge \textsf{path}(y, z)
\right)
$$</div>

<p>and in the min-plus semi-ring:</p>

<div class="kdmath">$$
\textsf{path}(x, z) = 
  \min\left(
  \textsf{edge}(x, z),
  \min_y
  \left(
    \textsf{edge}(x, y) \wedge \textsf{path}(y, z)
  \right)
\right)
$$</div>

<p>This idea greatly enriches the kinds of programs you can write in Datalog.
The <a href="https://web.cs.ucdavis.edu/~green/papers/pods07.pdf">Provenance Semirings</a>
 paper is a seminal reference on this topic,
 and it also demonstrated another cool use case: provenance.
This infrastructure can be used to 
 to compute how a tuple was derived by a Datalog program.
For example, in our shortest path program,
 instead of computing the shortest path,
 we could compute the path(s) themselves!
What do we do if we there are multiple paths?
In its most general form, 
 the provenance records all possible ways to compute the relevant tuple.
This is indeed expensive, 
 and implementing this in practice is the subject of quite a few papers.
But one key idea
 is that by adding in different kinds of algebraic restrictions,
 you can get more efficient algorithms.
The lack of the restrictions can collide with 
 the semi-naive algorithm.
A recent work presented <a href="https://arxiv.org/pdf/2105.14435.pdf">Datalogo</a>,
 a framework for working with semi-rings and preserving the ability to do semi-naive.</p>

<h3 id="existentials-adts-egds-and-tgds">Existentials, ADTs, EGDs, and TGDs</h3>

<p>Datalog is very restrictive on what kinds of things you can put in the head of a rule.
Negation, for example, is rarely allowed in the head.
We just saw about how even plain-old Datalog features
 (implicit) existential quantification in the body of a rule.
But what if we want to put an existential in the head?</p>

<p>First of all,
 what does that even mean?
Well, it makes sense from a logical perspective.
Datalog rules model an implication,
 and we can easily think of formulas like:</p>

<div class="kdmath">$$
\forall(x). \left( \textsf{person}(x) \implies \exists y. \textsf{parent}(x, y) \right)
$$</div>

<p>This makes sense as a formula, but cannot be written in vanilla Datalog.
The variable $y$ isn’t bound by the body of the rule,
 so it’s not clear what it means to have it in the head.</p>

<p>An algorithm called <a href="https://en.wikipedia.org/wiki/Chase_(algorithm)">the chase</a>
 from database theory is a sort of generalization of Datalog.
It allows two kinds of “rules” which it calls dependencies:</p>
<ul>
  <li><strong>Tuple Generating Dependencies</strong> (TGDs) are like Datalog rules.
They have a body and a head,
and they are used to derive new tuples.
But TGDs allows for existential quantification in the head.</li>
  <li><strong>Equality Generating Dependencies</strong> (EGDs) are used to enforce constraints.
They are used to enforce that certain values are equal.</li>
</ul>

<p>The chase is a complex topic with many flavors and variations
 that we won’t get into here.
Many of the variations revolve around how to deal with 
 the existential quantification in the head of a rule.
In general,
 the chase <em>does not terminate</em>,
 since the existential quantification in the head
 allows new values to be introduced at each step.</p>

<p>A restricted form of TGDs will look familiar to 
 PL folks however: they are essentially algebraic data types (ADTs).
ADTs are obviously powerful for modeling all kinds of tree-like data,
 and there are several Datalog implementation (including Souffle)
 that support them.
Their relation to TGDs is that they both
 allow for the creation of new values in the head of a rule.</p>
<div class="footnotes">
  <ol>
    <li id="fn:negation">

      <p>See <a href="https://pages.cs.wisc.edu/~paris/cs784-s17/lectures/lecture9.pdf">these notes</a> 
from Paris Koutris for a more detailed treatment. <a href="#fnref:negation" class="reversefootnote">&#8617;</a> <a href="#fnref:negation:1" class="reversefootnote">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:minplus">

      <p>This is a bit confusing because we are using addition for joint use, which is typically notated with $\times$. <a href="#fnref:minplus" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>


    <!-- <style>
        #topButton {
            position: fixed;
            bottom: 20px;
            right: 30px;
        }
    </style>
    <button id="topButton">
        <a href=" #"> Back to top </a>
    </button> -->
</div>
  </main>
  <footer>
    Site last updated on 2024-02-19.
    Edit me on <a href="https://github.com/mwillsey/cs294-260-sp24/blob/main/_posts/2024-02-05-datalog.md">Github</a>.
  </footer>
</body>

</html>