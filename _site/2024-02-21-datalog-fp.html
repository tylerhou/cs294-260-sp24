<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  
  <title> Functional Programming with Datalog | CS294-260 </title>
  
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta property="og:title" content="Functional Programming with Datalog" />
  <style>
    body {
      margin: 0 auto;
      max-width: 1200px;
      padding: 0 1em;
      background-color: #FED;
      color: #111;
      font-size: 120%;
      line-height: 1.2;
    }

    .center {
      text-align: center;
    }

    nav a {
      padding: 0.5ex;
    }

    footer {
      text-align: center;
      padding-top: 3em;
      color: #666;
      font-size: 70%;
    }
  </style>
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$']],
        processEscapes: true,
        tags: 'ams',
      },
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>
  <main>
    <h1 class="center"> Declarative Program Analysis and Optimization </h1>
    <h3 class="center"> CS294-260, Spring 2024 </h3>

    <nav class="center">
      <div id="links">
        <a href="/~cs294-260/sp24/">Home</a>
        
        <a href="/~cs294-260/sp24/2024-01-17-welcome">Policies</a>
        <a href="https://bcourses.berkeley.edu/courses/1532818">bCourses</a>
        
      </div>
    </nav>

    <style>
    #post {
        max-width: 800px;
        margin: 0 auto;
    }
</style>

<div id="post" class="content">

    <h2>Functional Programming with Datalog</h2>

    <ul>
        <li><time>Wednesday, February 21, 2024</time></li>
        
        <li class="lead">Discussion lead: Tyler, Jeremy</li>
        <ul>
            <li class="lead"> Reading guide due
                
                <b> Monday, February 19 </b>
                at 2:30pm
            </li>
        </ul>
        
        
        <li><a href="./papers/functional-programming-datalog.pdf">Paper link</a></li>
        
    </ul>

    <h2 id="summary">Summary</h2>

<p>We love Datalog. However, it is not easy to write and maintain large, complex
Datalog programs. “Functional Programming with Datalog” presents a small
functional language that compiles to Datalog rules; these rules can be
evaluated efficiently by existing Datalog engines like
<a href="https://souffle-lang.github.io/">Soufflé</a> and
<a href="https://dl.acm.org/doi/10.1145/3453483.3454026">IncA</a>. The core language
supports mutually recursive functions, if expressions, and variable bindings,
and uses the standard <em>demand transformation</em> to “control” the flow of
bottom-up evaluation. The language is extended first to support algebraic data
types (ADTs); then to support first-class sets, and first-class functions (via
<em>defunctionalization</em>). To evaluate their implementation, the authors write
various program analyses and an interpreter for the untyped lambda calculus.</p>

<h2 id="suggested-reading-strategy">Suggested reading strategy</h2>

<style>
  .rd-strat {
    border-collapse: collapse;
  }

  .rd-strat td, .rd-strat th {
    vertical-align: top;
    padding: 6px;
  }

  .rd-strat th {
    text-align: left;
  }

  .rd-strat tr:first-child td {
    border-top: 1px solid;
  }

  .rd-strat tr td {
    border-top: 0.5px solid gray;
  }

  .rd-strat td:nth-child(2), .sc {
    font-variant: small-caps;
  }

  .rd-strat {
    margin-top: 8px;
  }

  #o-read:checked ~ * tbody tr:not([data-read]) {
    display: none;
  }

  #o-read:not(:checked) ~ #o-read-th, #o-read:not(:checked) ~ #o-read-th-lb {
    display: none;
  }

  #o-read:checked ~ #o-read-th:checked ~ * tbody tr:not([data-read-thoroughly]) {
    display: none;
  }
</style>

<table class="rd-strat">
  <input type="checkbox" id="o-read" />&nbsp;
  <label for="o-read">Only show sections labeled "Read"</label>
  <br />

  <input type="checkbox" id="o-read-th" />&nbsp;
  <label for="o-read-th" id="o-read-th-lb">Only show sections labeled "Read thoroughly"</label>
  <br />

  <thead>
    <tr>
      <th colspan="2" width="25%">Section</th>
      <th>Strategy</th>
      <th>Summary / Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr data-read="" data-read-thoroughly="">
      <td>1.</td>
      <td>Introduction</td>
      <td><strong>Read thoroughly</strong></td>
      <td>
        Motivates the problem well; provides a good high level overview.
      </td>
    </tr>
    <tr data-read="">
      <td>2.</td>
      <td>Datalog Frontends: State of the Art</td>
      <td>Read</td>
      <td>
        Contrasts the paper’s approach with existing work, and suggests that
        Datalog could become an internal representation (IR) for future
        languages to target.
      </td>
    </tr>
    <tr data-read="" data-read-thoroughly="">
      <td>3.1</td>
      <td>Compilation by example</td>
      <td><strong>Read thoroughly</strong></td>
      <td>
        Presents the core language with a motivating example. See the notes for
        <a href="#non-terminating-queries-range-restriction-vs-infinite-relations">comments on the non-terminating factorial
        example.</a>
      </td>
    </tr>
    <tr>
      <td>3.2</td>
      <td>Translating functional programs to Datalog, technically</td>
      <td>Skim</td>
      <td>
        Technical details on how to compile <span class="sc">functional IncA</span> to Datalog. See the notes for an
        explanation of <a href="#figure-5">Figure 5.</a>
      </td>
    </tr>
    <tr data-read="" data-read-thoroughly="">
      <td>3.3</td>
      <td>Demand-driven bottom-up evaluation</td>
      <td><strong>Read thoroughly</strong></td>
      <td>
        Overview of the demand transformation. The demand transformation was
        presented in the <span class="sc"><a href="2024-02-14-slog">Slog</a></span> class
        and a precursor was presented as <span class="sc"><a href="2024-02-05-datalog#magic-sets">Magic
        Sets</a></span> in the Datalog lecture.
        </td>
    </tr>
    <tr data-read="" data-read-thoroughly="">
      <td>4.1</td>
      <td>Compiling user-defined data types by example</td>
      <td><strong>Read thoroughly</strong></td>
      <td>
        Overview of technique, and example with <code class="highlighter-rouge">plus</code> and <code class="highlighter-rouge">twice</code> for Peano
        numbers encoded in an ADT (<code class="highlighter-rouge">0 = Zero()</code>, <code class="highlighter-rouge">1 = Succ(Zero())</code>, etc.).
      </td>
    </tr>
    <tr>
      <td>4.2</td>
      <td>Extending functional IncA with ADTs</td>
      <td>Skim</td>
      <td>
        Technical details on how to extend <span class="sc">functional
        IncA</span> to support Algebraic Data Types.
      </td>
    </tr>
    <tr data-read="">
      <td>5</td>
      <td>Case study: Type Checking, Type Erasure, and Interpretation</td>
      <td>Read</td>
      <td>
        Description of type checker and interpreter written in <span class="sc">functional IncA</span> with ADTs.
      </td>
    </tr>
    <tr>
      <td>6</td>
      <td>Mixing functions and relations</td>
      <td style="overflow-wrap: break-word;">
        Skim; read 6.3 (pg. 20) if you are interested in defunctionalization
      </td>
      <td>
        Motivation, overview, and technical description on how to encode set
        objects in <span class="sc">functional IncA</span> as relations in
        Datalog.
      </td>
    </tr>
    <tr data-read="">
      <td>7</td>
      <td>Case Studies: Data-Flow Analyses and Clone Detection</td>
      <td>Read</td>
      <td>
        Description of flow-sensitive reaching definitions and interval
        analyses; clone detection of Java bytecode, written in <span class="sc">functional IncA</span>.
      </td>
    </tr>
    <tr data-read="">
      <td>8</td>
      <td>Implementation and Performance Evaluation</td>
      <td>Read</td>
      <td></td>
    </tr>
    <tr>
      <td>9</td>
      <td>Related work</td>
      <td style="overflow-wrap: break-word;">
        Skim
      </td>
      <td>
        Comparisons to and background for <span class="sc">Flix</span>, <span class="sc">Formulog</span>, <span class="sc">Datafun</span>, <span class="sc">Soufflé</span>, and <span class="sc">Dedalus/Bloom</span>.
      </td>
    </tr>
    <tr>
      <td>10</td>
      <td>Conclusion</td>
      <td style="overflow-wrap: break-word;">
        Skip
      </td>
      <td>
      </td>
    </tr>
  </tbody>
</table>

<h2 id="notes">Notes</h2>

<h3 id="non-terminating-queries-range-restriction-vs-infinite-relations">Non-terminating queries: range-restriction vs “infinite” relations</h3>

<p>Section 3.1 of the paper presents a factorial function that does not terminate:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fact(n, out) := n = 0, out = 1
fact(n, out) := n != 0, fact(n-1, out'), out = n * out'                   (1)
</code></pre></div></div>

<p>The authors say that the factorial function does not terminate because it is
not range-restricted. While this is true, we feel like the focus on
range-restriction is somewhat misleading. For example, in other <a href="https://www2.eecs.berkeley.edu/Pubs/TechRpts/2009/EECS-2009-173.pdf">Datalog
variants,</a>
one could model <code class="highlighter-rouge">n-1</code> as lookup into an “infinite” <code class="highlighter-rouge">successor</code> relation:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fact(n, out) := n != 0, successor(k, n), fact(k, out'), out = n * out'    (2)
</code></pre></div></div>

<p>In which case <code class="highlighter-rouge">fact</code> would indeed be range-restricted. However, bottom-up
computation of e.g. <code class="highlighter-rouge">fact(5)</code> would still not terminate because the <code class="highlighter-rouge">successor</code>
relation has infinite size. That is, lack of range-restriction is just one way
that a bottom-up evaluation might not terminate; another way that bottom-up
evaluation might not terminate is if rules include “infinite” relations in
their bodies (even if all rules are range-restricted).</p>

<p>The authors’ solution—the demand transformation—solves both cases of
non-termination. The observation is that a terminating functional program must
call <code class="highlighter-rouge">fact(n)</code> a finite number of times, and therefore we can guard <code class="highlighter-rouge">fact(n,
out)</code> with a demand relation <code class="highlighter-rouge">fact_input(n)</code> that stores every call. In the
original example (1), the rule is range-restricted, and hence terminates. In
the <code class="highlighter-rouge">successor</code> example (2), the join of <code class="highlighter-rouge">fact_input(n), successor(k, n)</code> is
finite, and so it too terminates.</p>

<h4 id="how-might-lack-of-range-restriction-cause-datalog-programs-to-not-terminate">How might lack of range-restriction cause Datalog programs to not terminate?</h4>

<p>Consider the model-theoretic semantics of Datalog. Recall that the Herbrand
universe $\mathcal{U}$ of a Datalog program $P$ is the set all non-variable
constants appearing in $P$, while the Herbrand base $\mathcal{B}$ is a set
containing predicates with their variables replaced with all possible values in
the Herbrand universe $\mathcal{U}$. For example, given the Datalog program</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>edge(1, 2) :-
edge(2, 3) :-
edge(3, 4) :-

P(x, y) :- edge(x, y)
P(x, y) :- P(x, y), edge(y, z)
</code></pre></div></div>

<p>The Herbrand universe $\mathcal{U}$ is $\mathcal{U} = \{1, 2, 3, 4\}$ and the Herbrand base
$\mathcal{B}$ is:</p>

<div class="kdmath">$$
\def\E{\texttt{edge}}
\def\P{\texttt{path}}
\mathcal{B} = \left\{\;
\begin{alignat*}{3}
  &\E(1, 1),\;\;    &\E(1, 2),\;\;    &\E(1, 3)\;\;    &\E(1, 4) \\
  &\E(2, 1),\;\;    &\E(2, 2),\;\;    &\E(2, 3)\;\;    &\E(2, 4) \\
  &\E(3, 1),\;\;    &\E(3, 2),\;\;    &\E(3, 3)\;\;    &\E(3, 4) \\
  &\E(4, 1),\;\;    &\E(4, 2),\;\;    &\E(4, 3)\;\;    &\E(4, 4) \\[3pt]
  &\P(1, 1),\;\;    &\P(1, 2),\;\;    &\P(1, 3)\;\;    &\P(1, 4) \\
  &\P(2, 1),\;\;    &\P(2, 2),\;\;    &\P(2, 3)\;\;    &\P(2, 4) \\
  &\P(3, 1),\;\;    &\P(3, 2),\;\;    &\P(3, 3)\;\;    &\P(3, 4) \\
  &\P(4, 1),\;\;    &\P(4, 2),\;\;    &\P(4, 3)\;\;    &\P(4, 4) \\
\end{alignat*}
\;\right\}
$$</div>

<p>An <em>interpretation</em> $I$ of a Datalog program $P$ is a subset $I$ of the
Herbrand base, $I \subseteq \mathcal{B}$, and a model $M$ is an interpretation
where every rule is satisfied over substitution of the rule’s variables with
constants from $\mathcal{U}$. That is, every model of $P$ must satisfy the
following (combinatorially many) sentences:</p>

<div class="kdmath">$$
\begin{align*}
  \E(1, 2) \\
  \E(2, 3) \\
  \E(3, 4) \\
\end{align*}
$$</div>

<div class="kdmath">$$
\begin{align*}
  \E(1, 1) &\rightarrow \P(1, 1) \\
  \E(1, 2) &\rightarrow \P(1, 2) \\
  \E(1, 3) &\rightarrow \P(1, 3) \\
           &\ldots               \\
  \E(2, 1) &\rightarrow \P(2, 1) \\
  \E(2, 2) &\rightarrow \P(2, 2) \\
           &\ldots               \\
  \E(4, 3) &\rightarrow \P(4, 3) \\
  \E(4, 4) &\rightarrow \P(4, 4) \\
\end{align*}
$$</div>

<div class="kdmath">$$
\def\AND{\;\wedge\;}
\begin{align*}
  \P(1, 1) \AND \E(1, 1) &\rightarrow \P(1, 1) \\
  \P(1, 2) \AND \E(2, 1) &\rightarrow \P(1, 1) \\
  \P(1, 3) \AND \E(3, 1) &\rightarrow \P(1, 1) \\
  \P(1, 4) \AND \E(4, 1) &\rightarrow \P(1, 1) \\
  \P(1, 1) \AND \E(1, 2) &\rightarrow \P(1, 2) \\
  \P(1, 2) \AND \E(2, 2) &\rightarrow \P(1, 2) \\
                         &\ldots               \\
  \P(2, 1) \AND \E(1, 1) &\rightarrow \P(2, 1) \\
  \P(2, 2) \AND \E(2, 1) &\rightarrow \P(2, 1) \\
                         &\ldots               \\
  \P(4, 3) \AND \E(3, 4) &\rightarrow \P(4, 4) \\
  \P(4, 4) \AND \E(4, 4) &\rightarrow \P(4, 4) \\
\end{align*}
$$</div>

<p>Note that most of the above sentences are trivially satisfied because their
antecedent is false (for example, $\E(1, 1) = \texttt{false}$, which means the
minimal model excludes $\P(1, 1)$, since its antecedent is never satisfied).</p>

<p>However, what happens if we add a rule whose head has an unbound variable, like
<code class="highlighter-rouge">bad(x, y, n) :- edge(x, y)</code>? This injects even more sentences into the set
of sentences a model has to satisfy:</p>

<div class="kdmath">$$
\def\B{\texttt{bad}}
\begin{align*}
  \E(1, 1) &\rightarrow \B(1, 1, 1) \\
  \E(1, 1) &\rightarrow \B(1, 1, 2) \\
  \E(1, 1) &\rightarrow \B(1, 1, 3) \\
  \E(1, 1) &\rightarrow \B(1, 1, 4) \\
  \E(1, 2) &\rightarrow \B(1, 2, 1) \\
  \E(1, 2) &\rightarrow \B(1, 2, 2) \\
  \E(1, 2) &\rightarrow \B(1, 2, 3) \\
  \E(1, 2) &\rightarrow \B(1, 2, 4) \\
           &\ldots                  \\
\end{align*}
$$</div>

<p>And in particular, since our model must satisfy the sentences with e.g. $\E(1,
2)$ in the antecedent, every model (and so therefore the minimal model) must
contain many “useless” facts $\B(1, 2, 1), \B(1, 2, 2), \B(1, 2, 3), \ldots$,
and so on. In addition, if the Herbrand universe is not finite (e.g. it
contains all integers), the minimal model could be infinite, and a bottom up
evaluation would never terminate!</p>

<p>This is the motivation behind range-restriction. A rule is range-restricted if
every variable in the head is bound in the body. Intuitively, for every rule,
the facts generated by that rule must have constants that appear in some
relation in the body of the rule. Thus, the sizes of the body relations serve
as a bound on the size of the head relation, and if the body relations have
finite size, then the head relation also has finite size.</p>

<h3 id="figure-5">Figure 5</h3>

<p>Translating an expression in <span class="sc">functional IncA</span> to Datalog
results in a set containing tuples $(t, a)$. For each tuple $(t, a)$, the
expression evaluates to value $t$ if the conditions in $a$ are satisfied. $a$
is a collection of Datalog antecedents, and can be roughly thought of encoding
the “control-flow” paths (branches, function calls) the program must take in
order to evaluate to $t$.</p>

<p>For example, the rewrite rule for <code class="highlighter-rouge">if</code> is the union of two sets. The first set
denotes the possible values the entire if-expression could evaluate to if the
condition is true. This requires that $t_1$ evaluates to $\textsf{true}$,
guarded by its own guards $a_1$. The resulting value $t_2$ must also be guarded
by its own tuples $a_2$ (consider an if expression nested within another if
expression). The second set is analogous, except for the false case.
The union of both sets represents all possible values the entire expression
might evaluate to in either case.</p>

<h3 id="reading-questions">Reading questions</h3>

<ol>
  <li>Compare and contrast <span class="sc">functional IncA</span> with <span class="sc">Doop</span>, <span class="sc">Flix</span>, and <span class="sc">Slog</span>.</li>
  <li>How does <span class="sc">functional IncA</span> encode control flow into
Datalog?</li>
  <li>How does <span class="sc">functional IncA</span> support algebraic data
types? How does its implementation differ from <span class="sc">Slog</span>’s?</li>
  <li>Explain the demand transformation as succinctly as you can.</li>
  <li>How do the authors add support for querying Datalog relations from <span class="sc">functional IncA</span>? How “clean” is their approach?</li>
</ol>

<h3 id="discussion-questions">Discussion questions</h3>

<ol>
  <li>What are the advantages of targeting Datalog as a backend for a functional
language? What are the disadvantages?</li>
  <li>Datalog engines like Soufflé might not support all features that a
functional language might need, like user-defined aggregations, or negation.
How might these limitations affect the power of <span class="sc">functional
IncA<span>?</span></span></li>
  <li>What language features might be challenging to support in extensions to
<span class="sc">functional IncA</span>?</li>
</ol>

<p>See also:</p>

<ul>
  <li><a href="https://dl.acm.org/doi/abs/10.1145/1836089.1836094">The demand transformation</a></li>
  <li><a href="https://dl.acm.org/doi/10.1145/28659.28689">Magic sets</a></li>
</ul>


    <!-- <style>
        #topButton {
            position: fixed;
            bottom: 20px;
            right: 30px;
        }
    </style>
    <button id="topButton">
        <a href=" #"> Back to top </a>
    </button> -->
</div>
  </main>
  <footer>
    Site last updated on 2024-02-19.
    Edit me on <a href="https://github.com/mwillsey/cs294-260-sp24/blob/main/_posts/2024-02-21-datalog-fp.md">Github</a>.
  </footer>
</body>

</html>